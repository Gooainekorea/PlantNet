# 나도 할 수 있다! 머신러닝 학습 및 모델을 이용한 웹 어플리케이션 만들기
본 프로젝트는 크게 두 부분으로 나눠져 있습니다.

PlantNet_ML : 머신러닝 학습 프로그래밍을 구현

PlantNet_App : PlantNet_ML을 이용해 생성한 머신러닝 모델을 이용해 식물 분류 웹 어플리케이션을 구현


# 01. PlantNet_ML
예제코드 : [Olly Rennard님의 Kaggle - Pl@ntNet](https://www.kaggle.com/code/ollyrennard/pl-ntnet/notebook)

해당 머신러닝 학습 프로그래밍에서는 논문 결과의 재현 및 실현한 코드를 참고해 

어떻게 하면 더 효율적이고 안정적으로 모델을 학습 시킬 수 있을지에 초점을 맞췄습니다.

- 학습 파이프라인 최적화 및 실용적 구현
- kornia를 활용한 GPU가속 증강으로 CPU 병목 감소 (성능 및 효율성 향상)
- 클래스 불균형 해소를 위해 손실 함수에 가중치 적용
- 별도의 데이터 전처리 구현

자세한 부분은 [PlantNet_ML.md](PlantNet_ML/PlantNet_ML.md) 참고

# 02. PlantNet_App
PlantNet_ML을 이용해 생성한 머신러닝 모델을 이용해 식물 분류 웹 어플리케이션을 구현

FastAPI 를 이용해 파이썬 서버와 노드js서버 연동

웹js - 프론트엔드 동작

js서버  - 백엔드

파이썬서버 - 모델 돌리고 출력된 학명을 위키검색해 가져옴

# 방화벽
나 이거 node.js랑 python서버 포트 방화벽 tcp 프로토콜에 대해 해제함
같은 컴퓨터에서 FAST API랑 EXPRESS로 만들고 REST API로 통신하게 했지만 
QR로 사진업로드 구현할때 해제했음. 그냥 인터넷에서 할꺼면 방화벽 해제 필요없음

# 이렇게 한이유
파이썬도 으로 모델 학습해서 tkinter로 배포하는것보다 html 배웠는데 이걸로 동적웹으로 구현하면 더 편하지 않을까 했다.
웹서비스를배웠는데 굳이 불편한 그래픽을 선택할 이유가 있나?
1. api 배움 + 파이썬배움 + html,css,js배움 + 동적 웹페이지 배움
2. node.js 해봄, FAST API 금방 배운다함
3. 시간 촉박함. 모델학습에 있어서 환경설정과 가중치 조정에 예상시간보다 더 많이 걸림.
4. 죄다 섞기.
    일단 파이썬으로 모델 불러다 값을 출력하면 그걸 html로 보여주면 되는거 아님? 
    ㅇㅋㅇㅋ 나라면 쌉가능 함. (이때 병목현상 해결하고 가중치 감쇠로 모델학습 성공해서 자신감 만땅이었음)
    그리고 웹에서 동작되자 이것저것 추가함
    
5. 여름방학전에 파이썬 크롤링을 배움. 출력값으로 검색결과 긁어오면 좋을꺼같았음 -> wikiapi를 찾음 (예아 크롤링 할 필요 없음)
6. 한국어로 검색결과가 빈약해서 영어로 검색함. 그리고 번역을 위한 api가 있는지 찾아봄 -> 사람들 생각 다 비슷했다. google번역 사용하는 비공식 툴이 있었음.
  - 아 근데 이거 트래픽땜시 종종 차단되는건 알고 쓰는게 좋음. 파파고는 번역 API 서비스 예전에 종료했더라

## 굳이 node.js와 python.py로 나눈 이유
일단 모델학습과 ㄱ웹서버는 노트북에서 돌려야했음. 그래서 노트북에다가는 웹어플리케이션만 돌림 

1. 모델학습하고 확인하려고 gui_test.py 만들때 부터 분리 생각함.
  - 모델구축후 생성된 저장된 모델 정보를 로드해서 모델만들면 그걸로 돌리면됨 
  - 근데 그 서버가 사용자와 소통까지 담당한다해도 어짜피 모델 추론은 분리된 영역에서 실행될텐데?
  - 그럼 서버가 하나일 필요가 있나?
2. 난 리엑트 못함.
  - node.js로는 JS로 동적웹페이지를 구현 가능하다는걸 알게 되고나서는 이걸 쓰기 시작함.
3. python으로는 데이터 핸들링, 모델학습과 크롤링 위주로 배움.
4. 웹 서버는 java나 c를 배웠는데 나는 이걸로 서버를 만들면 존나 오래걸린다는걸암.
5. python도 버전관리가 중요함. 
  - 근데 난 초반에 자바와 이클립스 버전문제때문에 안돌아간적 있었음
  - 이것들로 만들면 서버구동전에 자바버전 맞추고 이클립스 버전 맞추다가 시간가고 버전 때문에 안돌아가서 뭐하나 구현할때마다 에러날듯
6. 이미지 분석 모델의 추론과정은 컴퓨터 자원을 많이씀. 
  - 모델학습시 시스템 자원확인하면 장난아님.
  - 근데 이걸로 java와 이클립스, python을 다 돌린다고? 이야....
  - 굳이 무거운 서비스들을 우겨넣지 않아도 되는데 왜 그렇게 만들어야함?

결론 : 
촉박한데 거기에 Python 웹서버 개발보다. 그냥 만지작대던 node.js로 백엔드 서버를 만들고 python서버와 api로 연결시키는게 여러모로 빠를듯

---
# 단계별로 정리할 시간없어 올리는 포트폴리오 전문
● 프로젝트 개요
  - PC 및 모바일(QR 코드 연동)을 통한 식물 사진 업로드
  - PyTorch(AlexNet) 기반 딥러닝 모델을 이용한 식물 종 분류
  - Wikipedia API 를 연동한 식물 정보(일반명, 설명) 조회 및 번역
  - 분석된 식물 사진을 서버에 저장하는 기능

● 프로젝트 목표
  - 사용자가 식물 사진을 업로드하면, 딥러닝 모델을 통해 식물의 종을 식별합니다.
  - 식별된 식물의 학명, 일반명, 그리고 위키백과(Wikipedia) 기반의 상세 설명을 사용자에게 제공합니다.
  - PC 와 모바일 환경 모두에서 손쉽게 이미지를 업로드하고 분석할 수 있는 직관적인 사용자 인터페이스(UI)를 구축합니다.
  - 사용자가 업로드한 이미지를 서버에 저장하여 데이터베이스를 확장할 수 있는 기능을 제공합니다

● 테스트

에폭기록
진행별 학습그레프
CPU 병목 해결











● 딥러닝 워크플로우



● 최종 학습 그래프


● 계획

AI 모델 서버
실행 시나리오
계획
식물 분석하기 버튼누르면 app.js에서 식물사진 보내고 
server.js에서 사진이랑 요청 보내면 
plant_model.py에서 모델 불러다 분석해서 
server.js에 주면 클라이언트 화면에 데이터를 렌더링한다.

할것
plant_model.py(이후 기능 확장되며 python_server.py로 변경):
PIL/tkinter GUI 관련 코드 제거
REST API 엔드포인트로 변환 (FastAPI 사용)
이미지를 받아서 모델로 분석하고 결과 반환하는 함수만 유지
server.js:
이미지 업로드를 처리하는 새로운 엔드포인트 추가
Python API로 이미지 전송하는 로직 추가
분석 결과를 클라이언트에 반환
app.js:
이미지 업로드 및 분석 버튼 클릭 시 서버로 이미지 전송
받은 분석 결과를 화면에 표시

확인사항
Python 웹 서버로 Flask나 FastAPI 중 어떤 것이 좋을지 
	Flask- 쉬움 FastAPI- 속도빠름, 디버깅효율좋음
	FastAPI
이미지 업로드 시 어떤 형식으로 전송할지 - multipart/form-data(이진데이터 형식)
서버 포트 설정
Express 서버의 포트 : 3000
Python 서버의 포트 : 5000

웹서버 : FastAPI
데이터전송 : multipart/form-data
포트 : Express 서버의 포트 : 3000, Python 서버의 포트 : 5000
1. Pl@ntNet-300K 데이터셋을 다운로드하고, 학습/검증/테스트 폴더로 정리.​
1. Python 3.8 이상 설치
2. Node.js LTS 버전 설치
3. (GPU 사용 시) NVIDIA 드라이버와 CUDA Toolkit 13.0을 설치
4. Node.js 서버에 필요한 패키지를 설치 npm install
5. Python 가상 환경을 만들고 활성화
      python -m venv venv -> venv\Scripts\activate
6. Python 서버에 필요한 패키지
      pip install –r src\requirements.txt
7. 방화벽 인바운드 규칙 설정
8. 두 개의 터미널을 열고 가상환경 활성화, 각각 서버를 실행
9. 터미널 1 (Node.js 서버): node server.js
10. 터미널 2 (Python 서버): uvicorn src.plant_model:app --host 127.0.0.1 --port 5000

초기 환경 설정 시 C++ 패키지 손상으로 인한 오류가 발생했으나, 재설치를 통해 해결함.


AlexNet 사용 이유 – 최신 모델을 사용하는 것 보다. 자료 찾기 쉽고 레이어 구조가 직관적인 AlexNet을 구현 및 최적화 하는 것이 학교에서 배운 CNN(합성곱 신경망의) 구조와 데이터 흐름의 원리를 학습하는데 더 좋을 꺼라고 생각했다.

● 시스템 아키텍처 및 워크플로우
1. app.js(Client) 
  사용자가 ‘식물 분석’ 요청 시 이미지를 FormData로 Node.js 서버에 전송
2. server.js(JS Server)
  클라이언트 요청 수신 -> Python 서버로 중계
3. server.js(JS Server)
  - 모델 추론만 하는 plant_model.py에서 API서버 형태로 확장하여 plant_server.py로 파일명 변경
  - FastAPI를 통해 이미지 수신 및 전처리
  - 학습 모델(AlexNet)추론 수행 후 결과 반환
  - plant_model.py에서 API서버 형태로 확장 개발
4. API
  사용자가 ‘식물 분석’ 요청 시 이미지를 FormData로 Node.js 서버에 전송d 예측된 학며을 바탕으로 Wikipedia 정보 조회, googletrans를 통한 한글 번역 후 클라이언트에 전달

● 와이어프레임






● 파트별 상세 설명
Client Interface (Frontend) : js/app.js, index.html
사용자가 식물 이미지를 선택하고, 분석을 요청하며, 결과를 확인하는 전체 과정을 담당하는 싱글 페이지 애플리케이션
이미지 업로드:
1. PC : '사진 선택' 버튼을 통한 로컬 파일을 직접 업로드할 수 있습니다.
1. 모바일 QR 연동: qrcode.js 를 활용,
- 서버로부터 고유 세션 ID 와 로컬 IP 를 받아 QR 코드를 생성
- 사용자가 모바일로 QR 스캔 후 사진을 업로드,
- 프론트엔드는 서버의 상태를 주기적으로 확인하여 이미지가 준비되면 자동으로 화면에 표시.

API 통신: fetch API 를 사용하여 Node.js 서버의 엔드포인트(/api/analyze, /api/save-plant 등)와 비동기 통신을 수행
분석이 완료되면 서버로부터 받은 학명, 일반명, 설명 등의 데이터를 파싱하여 결과 창에
동적으로 렌더링

Application Layer (Backend) : server.js 3000
클라이언트와 AI 서비스(Python 서버) 간의 중재자(Mediator) 역할을 수행하는 Node.js 기반 API 서버.
API 라우팅: Express.js 를 사용하여 RESTful API 엔드포인트를 구축.
multer 미들웨어(node.js 파일업로드 미들웨어)를 사용하여 클라이언트로부터 업로드된 파일을 처리.
분석용 이미지는 메모리(buffer)에 저장하여 Python 서버로 전달 저장용 이미지는 디스크(images/plants/)에 영구 저장
QR 업로드 관리: 모바일 QR 업로드를 위해 세션 ID 를 키로 하는 임시 객체(mobileUploads)를 메모리에 유지. 모바일에서 사진이 업로드되면 해당 세션의 상태를 'completed'로 변경하고 이미지 데이터를 Base64 로 인코딩하여 저장
AI Service (Backend) : python_server.py 5000 
FastAPI - 파이썬 서버 
Postman - 파이썬 서버 응답 확인
역할: 실제 딥러닝 모델을 통해 이미지 분석 및 정보검색을 수행하는 Python 기반 서버. 
FastAPI -> PyTorch 모델(best_model.pth)을 로드, 엔드포인트를 통해 이미지 분석 요청을 처리.
입력된 이미지 바이트를 PIL 과 torchvision.transforms 를 통해 모델이 요구하는 텐서(Tensor) 형식으로 변환하고 정규화.

정보 검색 및 번역(get_prediction()):
1.모델이 예측한 식물의 학명을 기반으로 wikipediaapi 를 사용하여 영문 및 국문 위키백과 페이지를 검색.
2.국문 페이지가 없을 경우, 영문 요약 정보를 googletrans 라이브러리로 한국어로 번역하여 최종 설명과 일반명을 생성.
3.결과 반환: 분석된 학명, 일반명, 상세 설명을 포함한 JSON 객체를 Application Layer(Node.js 서버)로 반환.

● 실행 결과







● 이슈 발생 및 문제 해결 경험
1. 개발 환경 및 라이브러리 의존성 이슈
  초기 개발환경 세팅 시 원인 불명의 오류로 서버 구동이 불가한 현상 발생.
  원인 : Visual Studio의 C/C++컴파일러 관련 패키지 손상으로 인한 빌드 실패.
  해결 : C/C++워크로드 및 관련 런타임 구성요소 완전 삭재 후 재설치해 해결.

2. 크로스 플렛폼 멀티프로세싱 호환성 문제
  리눅스 환경에서 개발된 코드를 윈도우 환경으로 실행 시 프로세스 생성 관련 런타임 에러 발생.
  윈인 : 리눅스 fork()방식을 사용하지만, 윈도우는 spawn()방식 사용. 이로 이해 전역 범위의 코드가 자식 프로세스에서 반복 실행되었다.
  해결 : 학습 실행코드를 if __name__==“__main__”블록으로 캡슐화. 윈도우 환경에 맞게 서브 프로세스가 생성되도록 수정.







3. 데이터 전처리 및 학습 최적화
  3-1. 메타데이터 구조화 문제
    초기 전처리한 메타데이터로 인덱싱이 제대로 안되는 문제 발생,
    기존 예제 코드는 CSV형식을 사용했으나, 데이터의 계층적 구조와 확장성을 고려해 JSON형식이 더 적합하다고 판단해 독자적으로 도입 결정.
    원인 : Pandas등 라이브러리에서 CSV는 인덱스 기반 행/열 처리가 주를 이루지만, JSON은 딕셔너리 형태의 Key 매핑이 필요함을 파악
    해결 : JSON데이터 구조에 맞춰 데이터 로딩 파이프라인 재설계, JSON파싱후 딕형태로 매핑하는 로직을 새로 구현해 이미지 경로와 라벨을 올바르게 매칭

  3-2. I/O 병목 해결 - 하드웨어 가속 및 데이터 파이프라인 최적화
    GPU(CUDA)활성화 후에도 학습 속도가 현저히 느리고, GPU 사용율은 30%미만으로 낮으나 CPU사용율이 높은 병목 현상 발생.
    원인 1. 하드웨어 병목 현상
      습관적으로 D:\(HDD)에 프로젝트 폴더 생성. 이미지 파일을 로드하는데 있어 I/O Latency발생
      해결 : 데이터 저장소를 HDD에서 C:\(SDD(NVMe))로 이관해 물리적 I/O 속도 개선

    원인 2. PIL라이브러리의 이미지 처리 속도가 느림.
      Pillow-SIMD라이브러리 사용을 고려했으나 사용한 파이썬 버전과 호환이 되지 않았다.
      해결 : 이미지 로딩 라이브러리를 PIL에서 OpenCV로 교체 및 BGR-RGB변환 전처리 과정 추가로 처리 속도 향상

    원인 3. 데이터 로딩 병목 및 학습 속도 저하
      - CPU가 데이터로드, 리다이징, 증강을 모두 처리
      - 에폭마다 원본이미지를 다시 읽고 리사이징하는 연산 반복
        -> 대용량 이미지 학습시 데이터 로딩(I/O)와 전처리 속도가 GPU연산 속도를 따라가지 못함

      해결 : CPU 부화를 줄이고 GPU가동률을 높여 학습 속도 대폭 향상.
        1. 오프라인 전처리
          학습전, 전체 원본이미지를 모델 입력 규격인 224*224에 맞춰 미리 리사이징해 별도의 경로에 저장.
        2. GPU에 데이터 증강과 정규화 작업 이관
          CPU는 저장된 전처리 이미지를 로드하고 텐서로 변환하는 단순 작업만 수행
          nn.Sequential 과 Kornia를 활용해 증강 모듈 구축. 좌우/상하반전, 회전, 블러처리등을 GPU 텐서 연산으로 병렬 처리.
          사전학습 모델 특성유지를 위해 마지막 단계서 정규화 수행




4. 과적합 문제 - 모델 정의 및 설정 수정
  학습데이터에 대한 정확도는 높으나, 검증 및 테스트 데이터에 대한 분류 성능이 현저히 떨어지는 과적합 현상 발생(상단 표의 그래프들 참고)
  원인 : 데이터 불균형 문제 해결을 위해 적용한 손실함수의 가중치가 영향이 없음을 확인.
  해결 : 에폭별 모델 파라미터 출력. 가중치가 커짐을 확인. 클래스 샘플 수에 대한 가중치를 주는 것 뿐만 아니라 가중치를 억제해야함을 인지.
    내 생각보다 훨씬 낮은 1e-5로 학습률을 적용해 안정성을 높임.
    Optimizer에 weight_decay=5e-4를 설정해 가중치가 커짐을 억제.

5. 외부 API안정성 확보
  googletrans 라이브러리 사용 시 종종 번역 요청 차단 및 실패 발생.
  원인 : 트레픽 제한
  해결 : 예외처리로 서비스 중단 방지.

5. 위키결과에서 원래 생물분류도 가져오려고 했는데 class 중복이 많았음. 시간 촉박해서 주석처리로 빼버림

● 기타 – 파라미터 동결 여부에 따른 학습 비교 (오차역전파)
사전학습 모델에서 전체 파라미터를 재학습시 학습 그래프의 효율 비교
- 모든 레이어의 동결 해제후 전체 모델을 학습
결과 : Loss 폭★발
데이터가 많으니까 전체를 학습시키면 가진 데이터들에 맞춰져서 성능이 더 좋아질 줄 알았으나 
말도 안되는 그래프가 나왔다.
이유를 찾아보니 학습이 안된 마지막 레이어의 큰 오차가 뒤로 가면서 앞단 가중치까지 망쳐버린거였고 만약 전체를 맞춤설정 하려면 초기에 동결해 가중치를 맞춘후 점진적으로 미세 조정이 필요함을 알았다.
